/**
 * @file saveRoute.js
 * @project PathPal App
 * @description
 * Handles saving, unsaving, and naming of user-generated routes. Provides UI feedback via toast notifications,
 * manages per-profile saved state, and integrates with Mapbox reverse geocoding to generate human-readable route names.
 *
 * @author PathPal Team
 * @ai Use
 * Portions of this code were generated by AI as a learning aid and have been reviewed and refined to align
 * with PathPalâ€™s functionality requirements.
 */
(function () {
  document.addEventListener('DOMContentLoaded', () => {
    const saveBtn = document.getElementById('btn-save-route');
    if (!saveBtn) return;

    // Track saved state per profile
    const savedState = {
      driving:    { id: null, geom: null },
      walking:    { id: null, geom: null },
      senior:     { id: null, geom: null },
      wheelchair: { id: null, geom: null }
    };

// Toast setup
let toastEl = document.getElementById('save-toast');
if (!toastEl) {
  const wrap = document.createElement('div');
  // bottom-center, with a little padding
  wrap.className =
    'toast-container position-fixed bottom-0 start-50 translate-middle-x p-3';
  wrap.innerHTML = `
    <div
      id="save-toast"
      class="toast align-items-center text-white bg-dark border-0"
      role="alert"
      aria-live="assertive"
      aria-atomic="true"
    >
      <div class="d-flex">
        <div class="toast-body"></div>
        <button
          type="button"
          class="btn-close btn-close-white me-2 m-auto"
          data-bs-dismiss="toast"
          aria-label="Close"
        ></button>
      </div>
    </div>
  `;
  document.body.appendChild(wrap);
  toastEl = document.getElementById('save-toast');
}
    const showToast = msg => {
      toastEl.querySelector('.toast-body').textContent = msg;
      new bootstrap.Toast(toastEl, { delay: 2000, autohide: true }).show();
    };

    // Format helpers
    const formatDistance = m => m >= 1000 ? `${(m/1000).toFixed(1)} km` : `${Math.round(m)} m`;
    const formatDuration = s => `${Math.round(s/60)} min`;

    // Inline utility functions
    async function generateRouteName(routeGeoJSON) {
      const coords = routeGeoJSON.geometry?.coordinates;
      if (!Array.isArray(coords)) return { display: 'Saved Route', startFull: '', endFull: '' };
      const [start, end] = [coords[0], coords.at(-1)];
      const [startFull, endFull] = await Promise.all([
        reverseGeocode(start), reverseGeocode(end)
      ]);
      return { display: `${shortenAddress(startFull)} â†’ ${shortenAddress(endFull)}`, startFull, endFull };
    }
    async function reverseGeocode([lng, lat]) {
      try {
        const res = await fetch(
          `https://api.mapbox.com/geocoding/v5/mapbox.places/${lng},${lat}.json?access_token=${window.MAPBOX_TOKEN}`
        );
        if (!res.ok) return 'Unknown';
        const data = await res.json();
        return data.features?.[0]?.place_name || 'Unknown';
      } catch {
        return 'Unknown';
      }
    }
    const shortenAddress = full => full.split(',').slice(0,2).join(',');

    // Helper to get profile: use window.currentProfile if available, else fallback to active button
    function getProfile() {
      return window.currentProfile ||
        document.querySelector('#mode-buttons button.active')?.dataset.mode || 'driving';
    }

    // Initial load: populate state from URL routeId
    (() => {
      const params = new URLSearchParams(window.location.search);
      const routeId = params.get('routeId');
      const prof = getProfile();
      const geom = window.lastRouteGeoJSON?.geometry;
      if (routeId && geom) {
        savedState[prof].id = routeId;
        savedState[prof].geom = geom;
      }
      updateSaveButton();
    })();

    // Save/Unsave logic
    saveBtn.addEventListener('click', async () => {
      const prof = getProfile();
      const state = savedState[prof];
      const geom = window.lastRouteGeoJSON?.geometry;
      if (!geom) {showToast('No route to save.');return;
}

      if (state.id) {
        // Remove
        try {
          const res = await fetch(`/api/routes/${state.id}`, { method: 'DELETE' });
          if (!res.ok) throw 0;
          state.id = null; state.geom = null;
          showToast('Route removed successfully!');
        } catch {
          showToast('Failed to remove route.');
        }
      } else {
        // Save
        try {
          const { display, startFull, endFull } = await generateRouteName(window.lastRouteGeoJSON);
          const payload = {
            name: display,
            description: '',
            profile: prof,
            startAddress: startFull,
            endAddress: endFull,
            geometry: geom,
            steps: (window.lastRouteSteps || []).map(s => ({
              instruction: s.maneuver?.instruction||'â€”',
              distance: formatDistance(s.distance),
              duration: formatDuration(s.duration)
            })),
            summary: {
              distance: formatDistance(window.lastRouteSummary?.distance),
              duration: formatDuration(window.lastRouteSummary?.duration)
            }
          };
          const res = await fetch('/api/routes', {
            method: 'POST',
            headers: { 'Content-Type':'application/json' },
            body: JSON.stringify(payload)
          });
          if (!res.ok) throw 0;
          const data = await res.json();
          state.id = data._id; state.geom = geom;
          showToast('Route saved successfully!');
        } catch {
          showToast('Failed to save route.');
        }
      }
      updateSaveButton();
    });

    // Reset saved state on clear
    document.getElementById('dir-clear')?.addEventListener('click', () => {
      const prof = getProfile();
      savedState[prof].id = null;
      savedState[prof].geom = null;
      updateSaveButton();
    });

    // Poll for changes in profile or geometry to update button state
    let lastKey = null;
    setInterval(() => {
      const prof = getProfile();
      const geomObj = window.lastRouteGeoJSON?.geometry;
      const geomString = geomObj ? JSON.stringify(geomObj) : '';
      const params = new URLSearchParams(window.location.search);
      const routeIdParam = params.get('routeId');
      // Seed savedState from URL when a saved route loads
      if (routeIdParam && geomObj && savedState[prof].id !== routeIdParam) {
        savedState[prof].id = routeIdParam;
        savedState[prof].geom = geomObj;
      }
      const key = prof + '|' + geomString;
      if (key !== lastKey) {
        lastKey = key;
        updateSaveButton();
      }
    }, 500);

    function updateSaveButton() {
      const prof = getProfile();
      const state = savedState[prof];
      saveBtn.classList.remove('d-none');
      if (state.id) {
        saveBtn.textContent = 'âœ… Saved';
        saveBtn.classList.replace('btn-outline-success','btn-primary');
      } else {
        saveBtn.textContent = 'ðŸ“Œ Save This Route';
        saveBtn.classList.replace('btn-primary','btn-outline-success');
      }
    }
  });
})();